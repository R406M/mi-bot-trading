import os
import json
import logging
import pandas as pd
from flask import Flask, request
from kucoin.client import Trade, Market

# Configuración del logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Crear la aplicación Flask
app = Flask(__name__)

# Claves de API de KuCoin
KUCOIN_API_KEY = os.getenv("KUCOIN_API_KEY")
KUCOIN_SECRET_KEY = os.getenv("KUCOIN_SECRET_KEY")
KUCOIN_PASSPHRASE = os.getenv("KUCOIN_PASSPHRASE")

# Verificar si las claves están configuradas
if not all([KUCOIN_API_KEY, KUCOIN_SECRET_KEY, KUCOIN_PASSPHRASE]):
    raise EnvironmentError("Faltan claves de API de KuCoin en las variables de entorno.")

# Configurar cliente de KuCoin
trade_client = Trade(key=KUCOIN_API_KEY,
                     secret=KUCOIN_SECRET_KEY,
                     passphrase=KUCOIN_PASSPHRASE)
market_client = Market()

# Parámetros de trading
SYMBOL = "DOGE-USDT"
TIMEFRAME = "5min"  # Temporalidad ajustada
MAX_AMOUNT = 10  # Límite máximo por operación
TP_VALUE = 0.2  # Take Profit fijo en USDT
SL_VALUE = 10  # Stop Loss fijo en USDT

# Variable para controlar si una operación está activa
trade_active = False


# Función para abrir una orden
def place_order(action, amount):
    global trade_active
    try:
        if action == "buy":
            order = trade_client.create_market_order(SYMBOL, "buy", funds=amount)
        elif action == "sell":
            order = trade_client.create_market_order(SYMBOL, "sell", funds=amount)

        logger.info(f"Orden {action} ejecutada: {order}")
        trade_active = True  # Indicar que hay una operación activa
        return order
    except Exception as e:
        logger.error(f"Error al ejecutar la orden: {e}")
        return None


# Función para monitorear TP y SL
def monitor_tp_sl(action, entry_price):
    global trade_active
    try:
        while trade_active:
            ticker = market_client.get_ticker(SYMBOL)
            current_price = float(ticker['price'])

            if action == "buy":
                if current_price >= entry_price + TP_VALUE:
                    logger.info("Take Profit alcanzado (Buy). Cerrando operación.")
                    trade_client.create_market_order(SYMBOL, "sell", funds=MAX_AMOUNT)
                    trade_active = False
                elif current_price <= entry_price - SL_VALUE:
                    logger.info("Stop Loss alcanzado (Buy). Cerrando operación.")
                    trade_client.create_market_order(SYMBOL, "sell", funds=MAX_AMOUNT)
                    trade_active = False

            elif action == "sell":
                if current_price <= entry_price - TP_VALUE:
                    logger.info("Take Profit alcanzado (Sell). Cerrando operación.")
                    trade_client.create_market_order(SYMBOL, "buy", funds=MAX_AMOUNT)
                    trade_active = False
                elif current_price >= entry_price + SL_VALUE:
                    logger.info("Stop Loss alcanzado (Sell). Cerrando operación.")
                    trade_client.create_market_order(SYMBOL, "buy", funds=MAX_AMOUNT)
                    trade_active = False
    except Exception as e:
        logger.error(f"Error monitoreando TP/SL: {e}")
        trade_active = False


# Ruta para recibir señales de TradingView
@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        data = request.get_json()
        logger.info(f"Señal recibida: {data}")

        # Validar token secreto
        secret_token = os.getenv("WEBHOOK_SECRET", "default_token")
        if data.get("token") != secret_token:
            logger.warning("Token inválido recibido.")
            return {"status": "error", "message": "Token inválido"}, 403

        # Procesar la acción
        action = data.get("action")
        amount = data.get("amount", 50)

        # Logs adicionales para debug
        logger.info(f"Acción: {action}, Monto: {amount}")
        return {"status": "success", "message": "Señal procesada"}, 200
    except Exception as e:
        logger.error(f"Error procesando la señal: {e}")
        return {"status": "error", "message": str(e)}, 500


        # Validar si ya hay una operación activa
        if trade_active:
            return {"status": "error", "message": "Operación activa. Esperando cierre."}, 400

        # Validar acción
        action = data.get("action")
        amount = data.get("amount", 10)
        if action not in ["buy", "sell"]:
            return {"status": "error", "message": "Acción inválida."}, 400

        # Ejecutar la orden
        ticker = market_client.get_ticker(SYMBOL)
        entry_price = float(ticker['price'])  # Precio actual de mercado

        order = place_order(action, amount)
        if order:
            # Monitorear TP y SL
            monitor_tp_sl(action, entry_price)

        return {"status": "success", "message": "Operación ejecutada."}, 200

    except Exception as e:
        logger.error(f"Error en la recepción de la señal: {e}")
        return {"status": "error", "message": str(e)}, 500


if __name__ == "__main__":
    port = int(os.getenv("PORT", 5000))
    app.run(host="0.0.0.0", port=port)
